---
layout: page
group: 20
level: 1
title: A couple of points you may want to consider
---

One thing is constant: among those who will have to deliver to (or work with) an SData contract are 
technical people. Therefore, a large part of the contract should address this audience and provide the 
typical level of detail and accuracy required by development teams. 

The subsections below provide a list of things you may want to include/describe in your contract. 
Please view it as a guide and not as a directive.

### <a name="goal">Goal</a>

This could sound silly, but really stating what business benefit is achieved by complying with a 
contract can help a lot of people in their understanding (ex: is this relevant for me, what do I get if I 
comply,&hellip;). 

Try to describe the functional aspects of the contract - it will certainly be appreciated by the readers 
and implementers alike.

### <a name="provider-level">Provider level</a>

At this level you should consider specifying those aspects that pertain to the provider as a whole. 
Such aspects are:

*  Application **base URL** (i.e. the URL to reach the application): must it have a particular format (ex: 
for discoverability reasons)? This makes usually good sense to spell it out if the contract is native.
*  Is there an implementation of the **SData registry** present to support discoverability?
*  Intra-application URL segments:
    *  **Contract segment**: is it the default contract (-) or a named contract. 
    *  Contract **version segment**: it is good to think about the versioning of contracts, even if changes happen in large time intervals. 
    *  **Datasets/Tenants segment(s)**: are several tenants or datasets supported for a contract by an application? If so, do they need to be structured in specific segments of the URL?
*  Capabilities
    *  **$system**: is this provided? Are there other discovery mechanisms?
    *  **$schema**: is the application wide schema provided? If so and versioning is not done at the URL level, are there any specific ways to retrieve previous versions of a schema?
    *  **$batch**: are there any resource-independent batch operations provided?
    *  **$services**: are there any resource-independent predefined operations present? 
    *  **$queries**: are there any resource-independent predefined queries present? 
*  Provider-wide supported **query parameters** (see [section 2.11](../../core/0211/ "2.11 Query Parameters") of the SData 1.x standard) 
*  Provider-wide **metadata**: is there a subset of metadata and hypermedia controls present at every 
level (application and resources) 
*  **Security aspects**:
    *  Encryption 
    *  Authentication

### <a name="resources">Resources</a>

It seems a good idea to describe every individual resource covered by the contract. The following 
points should be considered on a per-resource-kind basis. 

### <a name="urls">URLs</a>

URLs are the addressing portion of a resource or a collection of resources. Stating explicitly what the 
URLs are will usually help the implementers significantly.

*  Resource collection URL: it is good to specify this
*  Single resource URL: it is a good practice to describe this. Ideally, describe this as a pattern (ex: 
&hellip;/customers('{customerID}') )

### <a name="payload-formatting">Payload formatting</a>

*  Are JSON and/or atom+xml supported?
*  If both are supported: 
    *  Which one is the default format?
    *  How can a consumer request the alternate format? Through the Accept header, and/or the format query parameter? 

### <a name="resource-structure">Resource structure</a>

The payload structure is a vital portion in the description of a resource; it goes beyond simply listing 
the properties and their meaning, it describes how properties belong together and the manner in 
which they should be treated.

It is meaningful to consider, for each property, the inclusion of the following aspects in the contract 
documentation: 

*  **Name**
*  **Description**
*  Kind
    *  **_Scalar_**: basic type (number, string, date, &hellip;), mime type, reference
    *  **_Group_**: contains a structured set of properties (is per definition immutable)
    *  **_Collection_** (to be thought of as an array of several items with identical structure)
        *  <u><i>Mutability</i></u>
            *  Immutable (cannot add/delete items from the collection)
            *  Mutable (can add/delete items). In this case, the collection can be altered by:
                *  passing complete collection 
                *  per partial update using $isDeleted metadata attribute
            *  <u><i>Collection Item</i></u>
                *  <u>Nature</u>
                    *  Embedded (can change the properties of items in place)
                    *  Reference
                        *  Lookup metadata control provided
                *  <u>Structure</u> (repeat, recursively as for the payload)

### <a name="operations">Operations</a>

The operations are essential. They usually go beyond the simple HTTP verbs as the list below shows. 
Consider documenting each of the below in your contract.

*  **Verbs** supported for this resource 
    *  **Read** operation
    *  **Update** operation
        *  Support of partial payloads (PUT, PATCH)
        *  Concurrency handling?
    *  **Create** operation
        *  Reliable POST supported?
        *  Concurrency handling?
    *  **Delete** operation
        *  Concurrency handling?
    *  **Query** operation
        *  Query language support: basic, intermediate, complete) (see [section 2.12](../../core/0212/ "2.12 Query Language") of standard) 
        *  Query parameter support: Include, Select, where, &hellip; (see [section 2.11](../../core/0211/ "2.11 Query Parameters") of standard)
*  **Hypermedia controls** (links): these augment the logical operational range on a resource by 
indicating the URL+operation+parameter combination required to perform a certain action; think 
of the <tt>next</tt> link in a paged set - it is a good example 

* **Services** ($services) and **Queries** ($query). For each service consider indicating the following
    *  Name
    *  Description
    *  URL and query parameters
    *  Access method (ex: PUT/POST/GET)
    *  Request structure, if a payload is relevant
    *  Response structure 
*  **Synchronization** support
    *  Synchronization source
    *  Synchronization target

### <a name="mechanisms-supported">Mechanisms supported</a>

*  **Batching**
*  Sync/async **invocation**
*  **Paging**
*  **Contract specific mechanisms** : if-and-only-if SData defined mechanisms could not be used

### <a name="capabilities">Capabilities</a>

*  **$schema** (xsd format)
*  **$template**
*  **$prototype** (JSON)
*  **Resource versioning** support
    *  Etag
    *  Modified date
    *  Version support
*  **Metadata** specific to a resource

### <a name="contract-provider-errors">Contract/provider specific errors</a>

It is a good idea to specify which error codes could be expected for the contract. Generally, these will 
be provider specific codes for native contracts, but in the context of domain contracts, finer 
graduations than the HTTP error codes are not uncommon. 

The error description should contain:

*  Error code
*  Context : resource + operation
*  Description
*  Remedies - if any 

***